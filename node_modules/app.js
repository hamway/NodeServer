var fs = require('fs');
var util = require('util');
var api = require('api');
var path = require('path');
var url = require('url');
var os = require('os');

/**
 * @TODO: Create module config
 * @type {*}
 */
exports.home = process.cwd();
exports.public = path.join(process.cwd(), '/public');
exports.configdir = path.join(this.home, '/config');
exports.configfile = path.join(this.configdir, '/config.json');
exports.config = null;

exports.prepare = function () {
    util.debug('Read config...');
    if (!fs.existsSync(this.configdir)) {
        process.on('exit', function () {
            util.error('Config directory not found');
        });
    }
    if (!fs.existsSync(this.configfile)) {
        process.on('exit', function () {
            util.error('Config file not found');
        });
    }
    var config = JSON.parse(fs.readFileSync(this.configfile));

    if (config.debug) {
        //var debug = require('debug');
    }

    var args = process.argv;

    if (args[2]) config.http.host = args[2];
    if (args[3]) config.http.port = args[3];

    this.config = config;
};

exports.setServer = function () {
    api.res.setHeader('Server', this.config.serverName);
}

exports.favicon = function () {
    var favicon = path.join(this.public, '/favicon.ico');
    this.getPublicFile(favicon);
}

exports.call = function () {
    var params = url.parse(api.url);
    switch (params.pathname) {
        case "/":
            var index = path.join(this.public, this.config.index);
            this.getPublicFile(index);
            break;
        case "/status":
            this.getStatus();
            break;
        default:
            exports.route(params);
    }
}
exports.route = function (params) {
    if (path.extname(params.pathname) != '') {
        var file = path.join(this.public, params.pathname);
        this.getPublicFile(file);
    } else {
        api.res.writeHead(200, {'Content-Type': 'text/plain'});
        api.res.write('Api method not registred');
        util.debug('Api method not registred');
    }
}
exports.getStatus = function () {
    var text = 'Hostname: ' + os.hostname() + os.EOL;
    text += 'Type: ' + os.type() + os.EOL;
    text += 'Platform: ' + os.platform() + os.EOL;
    text += 'Arch: ' + os.arch() + os.EOL;
    text += 'Release: ' + os.release() + os.EOL;
    text += 'Uptime: ' + os.uptime() + os.EOL;
    text += 'Load Average: ' + os.loadavg() + os.EOL;
    text += 'Totoal Memory: ' + os.totalmem() + os.EOL;
    text += 'Free Memory: ' + os.freemem() + os.EOL;
    text += 'Cpus: ' + JSON.stringify(os.cpus()) + os.EOL;
    text += 'Network: ' + JSON.stringify(os.networkInterfaces()) + os.EOL;
    text += 'TmpDir: ' + os.tmpdir() + os.EOL;
    text += 'Endianness: ' + os.endianness() + os.EOL;

    this.sendClient(text);
}

exports.sendClient = function (text) {
    api.res.writeHead(200, {'Content-Type': 'text/plain'});
    api.res.write(text, 'utf-8');
}

exports.getPublicFile = function (filepath, content) {
    var type = this.mime(filepath);

    if (filepath == undefined) this.destroy('Wrong file request');
    var mode = (
        type == "image/png" ||
            type == "image/x-icon" ||
            type == "image/jpeg" ||
            type == "image/gif") ? 'binary' : 'utf-8';

    if (fs.existsSync(filepath)) {
        api.res.writeHead(200, {'Content-Type': type});
        api.res.write(fs.readFileSync(filepath, mode), mode);
    } else {
        api.res.writeHead(404);
    }
}
/**
 * @TODO: Need create module
 * @param file
 * @returns {*}
 */
exports.mime = function (file) {
    ext = path.extname(file);
    list = JSON.parse(fs.readFileSync(path.join(this.configdir, '/mime.json'), 'utf-8'));
    type = list[ext];

    if (list[ext] == undefined) type = 'text/plain';

    return type;
}

exports.destroy = function (message) {
    process.on('exit', function () {
        util.error(message);
    });
}